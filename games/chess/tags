!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
AI	ai.h	/^class Chess::AI : public Joueur::BaseAI$/;"	c	class:Chess
Action	SkaiaAction.h	/^            Action(const Position& from, const Position& to, Type promotion) :$/;"	f	class:Skaia::Action
Action	SkaiaAction.h	/^    class Action$/;"	c	namespace:Skaia
BackAction	SkaiaBackAction.h	/^    class BackAction$/;"	c	namespace:Skaia
BitBoard	BitBoard.h	/^class BitBoard$/;"	c
BoardChecks	BoardChecks.h	/^class BoardChecks$/;"	c
Chess	chess.h	/^namespace Chess$/;"	n
Game	game.h	/^        Game() { this->name = "Chess"; };$/;"	f	class:Chess::Game
Game	game.h	/^class Chess::Game : public Joueur::BaseGame$/;"	c	class:Chess
GameManager	gameManager.cpp	/^Chess::GameManager::GameManager() :$/;"	f	class:Chess::GameManager
GameManager	gameManager.h	/^class Chess::GameManager : public Joueur::BaseGameManager$/;"	c	class:Chess
GameObject	gameObject.h	/^        GameObject() {};$/;"	f	class:Chess::GameObject
GameObject	gameObject.h	/^class Chess::GameObject : public Joueur::BaseGameObject$/;"	c	class:Chess
JOUEUR_CHESS_AI_H	ai.h	4;"	d
JOUEUR_CHESS_GAMEMANAGER_H	gameManager.h	5;"	d
JOUEUR_CHESS_GAMEOBJECT_H	gameObject.h	5;"	d
JOUEUR_CHESS_GAME_H	game.h	5;"	d
JOUEUR_CHESS_H	chess.h	2;"	d
JOUEUR_CHESS_MOVE_H	move.h	5;"	d
JOUEUR_CHESS_PIECE_H	piece.h	5;"	d
JOUEUR_CHESS_PLAYER_H	player.h	5;"	d
JOUEUR_CHESS_REGISTERY_H	registry.h	2;"	d
LOG	Skaia.h	11;"	d
MMReturn	SkaiaMM.h	/^    struct MMReturn$/;"	s	namespace:Skaia
Move	move.h	/^        Move() {};$/;"	f	class:Chess::Move
Move	move.h	/^class Chess::Move : public Chess::GameObject$/;"	c	class:Chess
Piece	SkaiaPiece.h	/^            Piece() : type(Empty), id(-1), special(true), alive(true) {}$/;"	f	class:Skaia::Piece
Piece	SkaiaPiece.h	/^            Piece(const Position& pos, Type type, Color color, size_t id, bool alive, size_t special = 0) :$/;"	f	class:Skaia::Piece
Piece	SkaiaPiece.h	/^    class Piece$/;"	c	namespace:Skaia
Piece	piece.h	/^        Piece() {};$/;"	f	class:Chess::Piece
Piece	piece.h	/^class Chess::Piece : public Chess::GameObject$/;"	c	class:Chess
Player	player.h	/^        Player() {};$/;"	f	class:Chess::Player
Player	player.h	/^class Chess::Player : public Chess::GameObject, public Joueur::BasePlayer$/;"	c	class:Chess
Position	Skaia.h	/^        Position() {}$/;"	f	struct:Skaia::Position
Position	Skaia.h	/^        Position(int rank, int file) : rank(rank), file(file) {}$/;"	f	struct:Skaia::Position
Position	Skaia.h	/^    struct Position$/;"	s	namespace:Skaia
SimpleSmallState	SkaiaSimpleSmallState.h	/^    struct SimpleSmallState$/;"	s	namespace:Skaia
Skaia	Skaia.cpp	/^namespace Skaia$/;"	n	file:
Skaia	Skaia.h	/^namespace Skaia$/;"	n
Skaia	SkaiaAction.h	/^namespace Skaia$/;"	n
Skaia	SkaiaBackAction.h	/^namespace Skaia$/;"	n
Skaia	SkaiaMM.cpp	/^namespace Skaia$/;"	n	file:
Skaia	SkaiaMM.h	/^namespace Skaia$/;"	n
Skaia	SkaiaPiece.h	/^namespace Skaia$/;"	n
Skaia	SkaiaSimpleSmallState.h	/^namespace Skaia$/;"	n
Skaia	SkaiaState.cpp	/^namespace Skaia$/;"	n	file:
Skaia	SkaiaState.h	/^namespace Skaia$/;"	n
Skaia	SkaiaState_internal.cpp	/^namespace Skaia$/;"	n	file:
SkaiaTest	SkaiaTest.cpp	/^void SkaiaTest()$/;"	f
Square	SkaiaState.h	/^                Square() : piece(nullptr), checks() {}$/;"	f	struct:Skaia::State::Square
Square	SkaiaState.h	/^                Square(Piece* piece) : piece(piece) {}$/;"	f	struct:Skaia::State::Square
Square	SkaiaState.h	/^                Square(Piece* piece, const std::bitset<32>& checks) : piece(piece), checks(checks) {}$/;"	f	struct:Skaia::State::Square
Square	SkaiaState.h	/^            struct Square$/;"	s	class:Skaia::State
State	SkaiaState.cpp	/^    State::State() : turn(0), pieces(), squares(),$/;"	f	class:Skaia::State
State	SkaiaState.cpp	/^    State::State(const State& source) : turn(source.turn), pieces(source.pieces), squares(),$/;"	f	class:Skaia::State
State	SkaiaState.h	/^    class State$/;"	c	namespace:Skaia
Zobrist	Zobrist.cpp	/^Zobrist::Zobrist(uint64_t seed) :$/;"	f	class:Zobrist
Zobrist	Zobrist.h	/^class Zobrist$/;"	c
action	SkaiaMM.h	/^        Action action;$/;"	m	struct:Skaia::MMReturn
actor	SkaiaBackAction.h	/^            Piece actor; \/\/ The previous state of the acting piece$/;"	m	class:Skaia::BackAction
alive	SkaiaPiece.h	/^            bool alive; \/\/ Whether or not this piece is still a part of the game$/;"	m	class:Skaia::Piece
apply_action	SkaiaState.cpp	/^    BackAction State::apply_action(const Action& action)$/;"	f	class:Skaia::State
apply_back_action	SkaiaState.cpp	/^    void State::apply_back_action(const BackAction& action)$/;"	f	class:Skaia::State
at	SkaiaState_internal.cpp	/^    State::Square& State::at(const Position& pos)$/;"	f	class:Skaia::State
at	SkaiaState_internal.cpp	/^    State::Square& State::at(int rank, int file)$/;"	f	class:Skaia::State
at	SkaiaState_internal.cpp	/^    const State::Square& State::at(const Position& pos) const$/;"	f	class:Skaia::State
at	SkaiaState_internal.cpp	/^    const State::Square& State::at(int rank, int file) const$/;"	f	class:Skaia::State
average_time	ai.h	/^        std::map<int, std::chrono::nanoseconds> average_time; \/\/ Holds the average time (in ns) it has taken to traverse down to the given depth$/;"	m	class:Chess::AI
canKill	SkaiaState_internal.cpp	/^    bool State::canKill(const Piece* piece, const Position& pos) const$/;"	f	class:Skaia::State
canTake	SkaiaState_internal.cpp	/^    bool State::canTake(const Piece* piece, const Position& pos) const$/;"	f	class:Skaia::State
captured	move.h	/^        Chess::Piece* captured;$/;"	m	class:Chess::Move
captured	piece.h	/^        bool captured;$/;"	m	class:Chess::Piece
castleing_values	Zobrist.h	/^        std::array<uint64_t, 8> castleing_values; \/\/ 0\/1\/2\/3 for White castle None\/King\/Queen\/Both side$/;"	m	class:Zobrist
check_bishop	SkaiaState_internal.cpp	/^    void State::check_bishop(const Piece* piece, bool check)$/;"	f	class:Skaia::State
check_king	SkaiaState_internal.cpp	/^    void State::check_king(const Piece* piece, bool check)$/;"	f	class:Skaia::State
check_knight	SkaiaState_internal.cpp	/^    void State::check_knight(const Piece* piece, bool check)$/;"	f	class:Skaia::State
check_pawn	SkaiaState_internal.cpp	/^    void State::check_pawn(const Piece* piece, bool check)$/;"	f	class:Skaia::State
check_piece	SkaiaState_internal.cpp	/^    void State::check_piece(const Piece* piece, bool check)$/;"	f	class:Skaia::State
check_pos	SkaiaState_internal.cpp	/^    void State::check_pos(const Piece* piece, const Position& pos, bool check)$/;"	f	class:Skaia::State
check_ray	SkaiaState_internal.cpp	/^    void State::check_ray(const Piece* piece, const Position& delta, bool check)$/;"	f	class:Skaia::State
check_rook	SkaiaState_internal.cpp	/^    void State::check_rook(const Piece* piece, bool check)$/;"	f	class:Skaia::State
checked_by_color	SkaiaState.h	/^                bool checked_by_color(Color color) const$/;"	f	struct:Skaia::State::Square
checks	BoardChecks.h	/^        std::array<std::pair<int, int>, 8 * 8> checks; \/\/ For each square, the heurisitc for white and black$/;"	m	class:BoardChecks
checks	SkaiaState.h	/^                std::bitset<32> checks;$/;"	m	struct:Skaia::State::Square
chessAI	gameManager.h	/^        Chess::AI* chessAI;$/;"	m	class:Chess::GameManager
chessGame	gameManager.h	/^        Chess::Game* chessGame;$/;"	m	class:Chess::GameManager
clientType	player.h	/^        std::string clientType;$/;"	m	class:Chess::Player
color	SkaiaPiece.h	/^            Color color; \/\/ 0=white, 1=black$/;"	m	class:Skaia::Piece
color	player.h	/^        std::string color;$/;"	m	class:Chess::Player
color_values	Zobrist.h	/^        std::array<uint64_t, 2> color_values; \/\/ [0] for White, [1] for Black$/;"	m	class:Zobrist
count_net_check_values	SkaiaState.cpp	/^    int State::count_net_check_values(Color color) const$/;"	f	class:Skaia::State
count_net_checks	SkaiaState.cpp	/^    int State::count_net_checks(Color color) const$/;"	f	class:Skaia::State
count_pawn_advancement	SkaiaState.cpp	/^    int State::count_pawn_advancement(Color color) const$/;"	f	class:Skaia::State
count_piece_moves	SkaiaState.cpp	/^    int State::count_piece_moves(Color color) const$/;"	f	class:Skaia::State
createGameObject	gameManager.cpp	/^Joueur::BaseGameObject* Chess::GameManager::createGameObject(const std::string& gameObjectName)$/;"	f	class:Chess::GameManager
currentPlayer	game.h	/^        Chess::Player* currentPlayer;$/;"	m	class:Chess::Game
currentTurn	game.h	/^        int currentTurn;$/;"	m	class:Chess::Game
data	BitBoard.h	/^        uint64_t data;$/;"	m	class:BitBoard
data	SkaiaSimpleSmallState.h	/^        std::array<uint64_t, 4> data;$/;"	m	struct:Skaia::SimpleSmallState
deltaUpdateField	game.cpp	/^void Chess::Game::deltaUpdateField(const std::string& fieldName, boost::property_tree::ptree& delta)$/;"	f	class:Chess::Game
deltaUpdateField	gameObject.cpp	/^void Chess::GameObject::deltaUpdateField(const std::string& fieldName, boost::property_tree::ptree& delta)$/;"	f	class:Chess::GameObject
deltaUpdateField	move.cpp	/^void Chess::Move::deltaUpdateField(const std::string& fieldName, boost::property_tree::ptree& delta)$/;"	f	class:Chess::Move
deltaUpdateField	piece.cpp	/^void Chess::Piece::deltaUpdateField(const std::string& fieldName, boost::property_tree::ptree& delta)$/;"	f	class:Chess::Piece
deltaUpdateField	player.cpp	/^void Chess::Player::deltaUpdateField(const std::string& fieldName, boost::property_tree::ptree& delta)$/;"	f	class:Chess::Player
direction_to	Skaia.h	/^        Position direction_to(const Position& to) const$/;"	f	struct:Skaia::Position
double_moved_pawn	SkaiaState.h	/^            Piece* double_moved_pawn; \/\/ Points to the one pawn that is capturable by en-passant, or nullptr$/;"	m	class:Skaia::State
double_moved_pawn_id	SkaiaBackAction.h	/^            int double_moved_pawn_id; \/\/ -1 if there was no previously double moved pawn$/;"	m	class:Skaia::BackAction
draw	SkaiaState.cpp	/^    bool State::draw() const$/;"	f	class:Skaia::State
empty	SkaiaState_internal.cpp	/^    bool State::empty(const Position& pos) const$/;"	f	class:Skaia::State
ended	ai.cpp	/^void Chess::AI::ended(bool won, std::string reason)$/;"	f	class:Chess::AI
enpassant_values	Zobrist.h	/^        std::array<uint64_t, 8> enpassant_values; \/\/ One for each file$/;"	m	class:Zobrist
file	Skaia.h	/^        int rank, file;$/;"	m	struct:Skaia::Position
file	piece.h	/^        std::string file;$/;"	m	class:Chess::Piece
file_from_skaia	Skaia.cpp	/^    std::string file_from_skaia(int file) { return std::string(1, 'a' + static_cast<char>(file)); }$/;"	f	namespace:Skaia
file_to_skaia	Skaia.cpp	/^    int file_to_skaia(const std::string& file) { return file[0] - 'a'; }$/;"	f	namespace:Skaia
from	SkaiaAction.h	/^            Position from, to;$/;"	m	class:Skaia::Action
fromFile	move.h	/^        std::string fromFile;$/;"	m	class:Chess::Move
fromRank	move.h	/^        int fromRank;$/;"	m	class:Chess::Move
game	ai.h	/^        Chess::Game* game;$/;"	m	class:Chess::AI
gameUpdated	ai.cpp	/^void Chess::AI::gameUpdated()$/;"	f	class:Chess::AI
generate_actions	SkaiaState.cpp	/^    std::vector<Action> State::generate_actions() const$/;"	f	class:Skaia::State
getName	ai.cpp	/^std::string Chess::AI::getName()$/;"	f	class:Chess::AI
hasMoved	piece.h	/^        bool hasMoved;$/;"	m	class:Chess::Piece
hash	SkaiaAction.h	/^    template<> struct hash<Skaia::Action> {$/;"	s	namespace:std
hash	Zobrist.h	/^        uint64_t hash;$/;"	m	class:Zobrist
heuristic	SkaiaMM.cpp	/^    int heuristic(const State& state, Color me, bool stalemate, bool draw)$/;"	f	namespace:Skaia
heuristic	SkaiaMM.h	/^        int heuristic;$/;"	m	struct:Skaia::MMReturn
history	SkaiaState.h	/^            boost::circular_buffer<uint64_t> history; \/\/ For detecting draws by repeat$/;"	m	class:Skaia::State
history_table	ai.h	/^        std::unordered_map<Skaia::Action, std::pair<int, int>> history_table;$/;"	m	class:Chess::AI
id	SkaiaPiece.h	/^            int id; \/\/ This will be an index into the vector of pieces$/;"	m	class:Skaia::Piece
idmm_busy	ai.h	/^        std::atomic_flag idmm_busy; \/\/ Set when a resource is busy$/;"	m	class:Chess::AI
idmm_stop	ai.h	/^        std::atomic<bool> idmm_stop;$/;"	m	class:Chess::AI
idmm_thread	ai.h	/^        std::thread idmm_thread;$/;"	m	class:Chess::AI
inCheck	player.h	/^        bool inCheck;$/;"	m	class:Chess::Player
inside	SkaiaState.h	/^            static bool inside(const Position& pos) { return inside(pos.rank, pos.file); }$/;"	f	class:Skaia::State
inside	SkaiaState.h	/^            static bool inside(int rank, int file) { return 0 <= rank && rank < 8 && 0 <= file && file < 8; }$/;"	f	class:Skaia::State
interruptable_minimax	SkaiaMM.cpp	/^    MMReturn interruptable_minimax(const State& cstate, Color me, int depth_remaining,$/;"	f	namespace:Skaia
is_in_check	SkaiaState.cpp	/^    bool State::is_in_check(Color color) const$/;"	f	class:Skaia::State
kill_piece	SkaiaState.cpp	/^    void State::kill_piece(Piece* piece)$/;"	f	class:Skaia::State
line_moves	SkaiaState_internal.cpp	/^    void State::line_moves(const Piece* piece, const Position& delta, std::vector<Action>& actions) const$/;"	f	class:Skaia::State
log	gameObject.cpp	/^void Chess::GameObject::log(std::string message)$/;"	f	class:Chess::GameObject
logs	gameObject.h	/^        std::vector<std::string> logs;$/;"	m	class:Chess::GameObject
madeMove	player.h	/^        bool madeMove;$/;"	m	class:Chess::Player
material	SkaiaState.cpp	/^    int State::material(Color color) const$/;"	f	class:Skaia::State
maxTurns	game.h	/^        int maxTurns;$/;"	m	class:Chess::Game
minimax	SkaiaMM.cpp	/^    MMReturn minimax(const State& cstate, Color me, int depth_remaining, int lower, int upper)$/;"	f	namespace:Skaia
move	piece.cpp	/^Chess::Move* Chess::Piece::move(std::string file, int rank, std::string promotionType)$/;"	f	class:Chess::Piece
move_piece	SkaiaState.cpp	/^    void State::move_piece(const Position& from, const Position& to)$/;"	f	class:Skaia::State
moves	SkaiaPiece.h	/^            std::vector<Action> moves; \/\/ A vector of all possible moves this piece can make$/;"	m	class:Skaia::Piece
moves	game.h	/^        std::vector<Chess::Move*> moves;$/;"	m	class:Chess::Game
name	player.h	/^        std::string name;$/;"	m	class:Chess::Player
names	Skaia.h	/^    static const std::vector<std::string> names = {"Empty", "Pawn", "Bishop", "Knight", "Rook", "Queen", "King"};$/;"	m	namespace:Skaia
old_action	SkaiaBackAction.h	/^            uint64_t old_action; \/\/ The eighth-oldest action to be re-added to history, or 0 if there isn't enough history$/;"	m	class:Skaia::BackAction
operator !	Skaia.cpp	/^Skaia::Color operator!(const Skaia::Color &color) { return color ? Skaia::White : Skaia::Black; }$/;"	f
operator !=	Skaia.h	/^        bool operator!=(const Position& rhs) const { return rank != rhs.rank || file != rhs.file; }$/;"	f	struct:Skaia::Position
operator !=	SkaiaAction.h	/^            bool operator!=(const Action& rhs) const$/;"	f	class:Skaia::Action
operator !=	SkaiaSimpleSmallState.h	/^        bool operator!=(const SimpleSmallState& rhs) const { return data != rhs.data; }$/;"	f	struct:Skaia::SimpleSmallState
operator ()	SkaiaAction.h	/^        size_t operator() (const Skaia::Action &a) const$/;"	f	struct:std::hash
operator *	Skaia.h	/^        Position operator*(int factor) const$/;"	f	struct:Skaia::Position
operator *=	Skaia.h	/^        Position& operator*=(int factor) { rank *= factor; file *= factor; }$/;"	f	struct:Skaia::Position
operator +	Skaia.h	/^        Position operator+(const Position& rhs) const$/;"	f	struct:Skaia::Position
operator +=	Skaia.h	/^        Position& operator+=(const Position& rhs) { rank += rhs.rank; file += rhs.file; }$/;"	f	struct:Skaia::Position
operator -	Skaia.h	/^        Position operator-(const Position& rhs) const$/;"	f	struct:Skaia::Position
operator -=	Skaia.h	/^        Position& operator-=(const Position& rhs) { rank -= rhs.rank; file -= rhs.file; }$/;"	f	struct:Skaia::Position
operator <	Skaia.h	/^        bool operator<(const Position& rhs) const { return rank < rhs.rank || (rank == rhs.rank && file < rhs.file); }$/;"	f	struct:Skaia::Position
operator <	SkaiaAction.h	/^            bool operator<(const Action& rhs) const$/;"	f	class:Skaia::Action
operator <<	Skaia.cpp	/^std::ostream& operator<<(std::ostream& out, const Skaia::Color& color)$/;"	f
operator <<	Skaia.cpp	/^std::ostream& operator<<(std::ostream& out, const Skaia::Position& pos)$/;"	f
operator <<	SkaiaAction.cpp	/^std::ostream& operator<<(std::ostream& out, const Skaia::Action& action)$/;"	f
operator <<	SkaiaPiece.cpp	/^std::ostream& operator<<(std::ostream& out, const Skaia::Piece& piece)$/;"	f
operator <<	SkaiaSimpleSmallState.cpp	/^std::ostream& operator<<(std::ostream& out, const Skaia::SimpleSmallState &sss)$/;"	f
operator <<	SkaiaState.cpp	/^std::ostream& operator<<(std::ostream& out, const Skaia::State& state)$/;"	f
operator ==	Skaia.h	/^        bool operator==(const Position& rhs) const { return rank == rhs.rank && file == rhs.file; }$/;"	f	struct:Skaia::Position
operator ==	SkaiaAction.h	/^            bool operator==(const Action& rhs) const$/;"	f	class:Skaia::Action
operator ==	SkaiaPiece.h	/^            bool operator==(const Piece& rhs) const$/;"	f	class:Skaia::Piece
operator ==	SkaiaSimpleSmallState.h	/^        bool operator==(const SimpleSmallState& rhs) const { return data == rhs.data; }$/;"	f	struct:Skaia::SimpleSmallState
operator ==	SkaiaState.cpp	/^    bool State::Square::operator==(const Square& rhs) const$/;"	f	class:Skaia::State::Square
operator ==	SkaiaState.cpp	/^    bool State::operator==(const State& rhs) const$/;"	f	class:Skaia::State
orderAI	gameManager.cpp	/^boost::property_tree::ptree* Chess::GameManager::orderAI(const std::string& order, boost::property_tree::ptree* args)$/;"	f	class:Chess::GameManager
otherPlayer	player.h	/^        Chess::Player* otherPlayer;$/;"	m	class:Chess::Player
owner	piece.h	/^        Chess::Player* owner;$/;"	m	class:Chess::Piece
pawn_move_with_promotions	SkaiaState_internal.cpp	/^    void State::pawn_move_with_promotions(const Piece* piece, const Position& to, std::vector<Action>& actions) const$/;"	f	class:Skaia::State
piece	SkaiaState.h	/^                Piece* piece;$/;"	m	struct:Skaia::State::Square
piece	move.h	/^        Chess::Piece* piece;$/;"	m	class:Chess::Move
piece_values	Zobrist.h	/^        std::array<uint64_t, 2 * 6 * 8 * 8> piece_values;$/;"	m	class:Zobrist
pieces	SkaiaState.h	/^            std::array<Piece, 32> pieces;$/;"	m	class:Skaia::State
pieces	game.h	/^        std::vector<Chess::Piece*> pieces;$/;"	m	class:Chess::Game
pieces	player.h	/^        std::vector<Chess::Piece*> pieces;$/;"	m	class:Chess::Player
pieces_by_color_and_type	SkaiaState.h	/^            std::array<std::array<std::vector<Piece*>, NumberOfTypes>, 2> pieces_by_color_and_type;$/;"	m	class:Skaia::State
place_piece	SkaiaState.cpp	/^    void State::place_piece(Piece* piece, const Position& pos)$/;"	f	class:Skaia::State
player	ai.h	/^        Chess::Player* player;$/;"	m	class:Chess::AI
players	game.h	/^        std::vector<Chess::Player*> players;$/;"	m	class:Chess::Game
pondering_busy	ai.h	/^        std::atomic_flag pondering_busy;$/;"	m	class:Chess::AI
pondering_depth	ai.h	/^        int pondering_depth;$/;"	m	class:Chess::AI
pondering_minimax	SkaiaMM.cpp	/^    std::vector<std::pair<Action, MMReturn>> pondering_minimax(const State& cstate,$/;"	f	namespace:Skaia
pondering_move	ai.h	/^        std::vector<std::pair<Skaia::Action, Skaia::MMReturn>> pondering_move;$/;"	m	class:Chess::AI
pondering_stop	ai.h	/^        std::atomic<bool> pondering_stop;$/;"	m	class:Chess::AI
pondering_thread	ai.h	/^        std::thread pondering_thread;$/;"	m	class:Chess::AI
pos	SkaiaPiece.h	/^            Position pos;$/;"	m	class:Skaia::Piece
possible_bishop_moves	SkaiaState_internal.cpp	/^    void State::possible_bishop_moves(const Piece* piece, std::vector<Action>& actions) const$/;"	f	class:Skaia::State
possible_king_moves	SkaiaState_internal.cpp	/^    void State::possible_king_moves(const Piece* piece, std::vector<Action>& actions) const$/;"	f	class:Skaia::State
possible_knight_moves	SkaiaState_internal.cpp	/^    void State::possible_knight_moves(const Piece* piece, std::vector<Action>& actions) const$/;"	f	class:Skaia::State
possible_pawn_moves	SkaiaState_internal.cpp	/^    void State::possible_pawn_moves(const Piece* piece, std::vector<Action>& actions) const$/;"	f	class:Skaia::State
possible_piece_moves	SkaiaState_internal.cpp	/^    void State::possible_piece_moves(const Piece* piece, std::vector<Action>& actions) const$/;"	f	class:Skaia::State
possible_rook_moves	SkaiaState_internal.cpp	/^    void State::possible_rook_moves(const Piece* piece, std::vector<Action>& actions) const$/;"	f	class:Skaia::State
print_checks	SkaiaTest.cpp	/^void print_checks(const Skaia::State& state, int piece_id)$/;"	f
print_debug_info	SkaiaState.cpp	/^    void State::print_debug_info(std::ostream& out) const$/;"	f	class:Skaia::State
promotion	SkaiaAction.h	/^            Type promotion;$/;"	m	class:Skaia::Action
promotion	move.h	/^        std::string promotion;$/;"	m	class:Chess::Move
random	Zobrist.h	/^        std::mt19937_64 random;$/;"	m	class:Zobrist
rank	Skaia.h	/^        int rank, file;$/;"	m	struct:Skaia::Position
rank	piece.h	/^        int rank;$/;"	m	class:Chess::Piece
rankDirection	player.h	/^        int rankDirection;$/;"	m	class:Chess::Player
rank_from_skaia	Skaia.cpp	/^    int rank_from_skaia(int rank) { return 8 - rank; }$/;"	f	namespace:Skaia
rank_to_skaia	Skaia.cpp	/^    int rank_to_skaia(int rank) { return 8 - rank; }$/;"	f	namespace:Skaia
ray_action	SkaiaState.h	/^            template<typename F> void ray_action(const Piece* piece, const Position& delta, F func)$/;"	f	class:Skaia::State
ray_action	SkaiaState.h	/^            template<typename F> void ray_action(const Position& from, const Position& delta, F func)$/;"	f	class:Skaia::State
ray_action_const	SkaiaState.h	/^            template<typename F> void ray_action_const(const Piece* piece, const Position& delta, F func) const$/;"	f	class:Skaia::State
remove_piece	SkaiaState.cpp	/^    void State::remove_piece(Piece* piece)$/;"	f	class:Skaia::State
rhs	SkaiaPiece.h	/^            Piece& operator=(const Piece& rhs) = default;$/;"	m	class:Skaia::Piece
runTurn	ai.cpp	/^bool Chess::AI::runTurn()$/;"	f	class:Chess::AI
san	move.h	/^        std::string san;$/;"	m	class:Chess::Move
session	game.h	/^        std::string session;$/;"	m	class:Chess::Game
setupAI	gameManager.cpp	/^void Chess::GameManager::setupAI(const std::string& playerID)$/;"	f	class:Chess::GameManager
sign	Skaia.h	/^    template<typename T> T sign(const T& x) { return (x > 0) - (x < 0); }$/;"	f	namespace:Skaia
since_pawn_or_capture	SkaiaBackAction.h	/^            int since_pawn_or_capture;$/;"	m	class:Skaia::BackAction
since_pawn_or_capture	SkaiaState.h	/^            int since_pawn_or_capture; \/\/ For detecting draws by no pawn move or piece captured$/;"	m	class:Skaia::State
source	Skaia.h	/^        Position& operator=(Position&& source) = default;$/;"	m	struct:Skaia::Position
source	Skaia.h	/^        Position& operator=(const Position& source) = default;$/;"	m	struct:Skaia::Position
source	Skaia.h	/^        Position(Position&& source) = default;$/;"	m	struct:Skaia::Position
source	Skaia.h	/^        Position(const Position& source) = default;$/;"	m	struct:Skaia::Position
source	SkaiaPiece.h	/^            Piece(const Piece& source) = default;$/;"	m	class:Skaia::Piece
special	SkaiaPiece.h	/^            int special; \/\/ True if this piece has never moved$/;"	m	class:Skaia::Piece
squares	SkaiaState.h	/^            std::array<Square, 8 * 8> squares;$/;"	m	class:Skaia::State
start	ai.cpp	/^void Chess::AI::start()$/;"	f	class:Chess::AI
state	ai.h	/^        Skaia::State state; \/\/ Store the board state between turns$/;"	m	class:Chess::AI
states_evaluated	SkaiaMM.h	/^        int states_evaluated;$/;"	m	struct:Skaia::MMReturn
std	SkaiaAction.h	/^namespace std$/;"	n
taken	SkaiaBackAction.h	/^            Piece taken; \/\/ The previous state of the taken piece (if one was taken), otherwise it is the default-constructed Piece$/;"	m	class:Skaia::BackAction
timeRemaining	player.h	/^        float timeRemaining;$/;"	m	class:Chess::Player
to	SkaiaAction.h	/^            Position from, to;$/;"	m	class:Skaia::Action
toFile	move.h	/^        std::string toFile;$/;"	m	class:Chess::Move
toRank	move.h	/^        int toRank;$/;"	m	class:Chess::Move
to_simple	SkaiaState.cpp	/^    SimpleSmallState State::to_simple() const$/;"	f	class:Skaia::State
toggle_color	Zobrist.cpp	/^void Zobrist::toggle_color(const Skaia::Color& color)$/;"	f	class:Zobrist
try_take	SkaiaState_internal.cpp	/^    void State::try_take(const Piece* piece, const Position& to, std::vector<Action>& actions) const$/;"	f	class:Skaia::State
turn	SkaiaState.h	/^            size_t turn;$/;"	m	class:Skaia::State
turn_end	ai.h	/^        std::chrono::time_point<std::chrono::steady_clock> turn_end; \/\/ Used to measure how long the opponent is taking$/;"	m	class:Chess::AI
turnsToDraw	game.h	/^        int turnsToDraw;$/;"	m	class:Chess::Game
type	SkaiaBackAction.h	/^            Type type; \/\/ To signify special moves like promotion$/;"	m	class:Skaia::BackAction
type	SkaiaPiece.h	/^            Type type;$/;"	m	class:Skaia::Piece
type	piece.h	/^        std::string type;$/;"	m	class:Chess::Piece
type_from_skaia	Skaia.cpp	/^    std::string type_from_skaia(Type type) { return names[type]; }$/;"	f	namespace:Skaia
type_to_skaia	Skaia.cpp	/^    Type type_to_skaia(const std::string& type)$/;"	f	namespace:Skaia
update_castling	Zobrist.cpp	/^void Zobrist::update_castling(const Skaia::Color& color, int state)$/;"	f	class:Zobrist
update_enpassant	Zobrist.cpp	/^void Zobrist::update_enpassant(int file)$/;"	f	class:Zobrist
update_piece	Zobrist.cpp	/^void Zobrist::update_piece(const Skaia::Position &pos, const Skaia::Color &color, const Skaia::Type &type)$/;"	f	class:Zobrist
~Game	game.h	/^        ~Game() {};$/;"	f	class:Chess::Game
~GameObject	gameObject.h	/^        ~GameObject() {};$/;"	f	class:Chess::GameObject
~Move	move.h	/^        ~Move() {};$/;"	f	class:Chess::Move
~Piece	piece.h	/^        ~Piece() {};$/;"	f	class:Chess::Piece
~Player	player.h	/^        ~Player() {};$/;"	f	class:Chess::Player
